# Taller ‚Äì Lenguaje Ensamblador (IA-32)

## Objetivo del taller

El objetivo de este taller es **aprender a traducir c√≥digo C a ensamblador IA-32**, utilizando:

* **C puro** (versi√≥n de referencia)
* **C + ensamblador en l√≠nea (`c_asm_‚Ä¶`)**
* **Funciones completamente en ensamblador (`asm_‚Ä¶`)**

A lo largo de los ejercicios se refuerzan conceptos como:

* Uso de registros
* Operaciones aritm√©ticas
* Estructuras de control
* Manejo de punteros

---

## Comando de compilaci√≥n (OBLIGATORIO)

‚ö†Ô∏è **Todos los ejercicios deben compilarse usando exactamente este comando**:

```bash
clang -m32 -masm=intel -fms-extensions -O0 -fno-pic \
      -fno-unwind-tables -fno-asynchronous-unwind-tables \
      -fno-omit-frame-pointer -fno-stack-protector main.c -o main
```

## Comando de ejecuci√≥n (OBLIGATORIO)

‚ö†Ô∏è **Todos los ejercicios deben ejercutarse usando exactamente este comando**:

```bash
./main
```

### ¬øQu√© hace este comando?

* `-m32`: fuerza compilaci√≥n a 32 bits
* `-masm=intel`: sintaxis Intel en ensamblador
* `-fms-extensions`: permite `__asm` estilo MSVC
* `-O0`: sin optimizaciones (clave para aprender)
* Las dem√°s opciones evitan que el compilador modifique la pila

---

## Estructura del taller

En el archivo ZIP encontrar√°s **8 carpetas**, una por ejercicio:

```
0_Divide
1_Multiply
2_Pointer
3_Abs
4_Max
5_Strlen
6_Reduction
7_Shift
```

---

# Ejercicio 0 ‚Äì Divide (EJEMPLO COMPLETO)

üìÇ **Carpeta:** `0_Divide`

Este ejercicio **ya est√° completamente resuelto** y sirve como **modelo** para los dem√°s.

### Qu√© debes hacer

* Estudiar cuidadosamente:

  * `c_divide`
  * `c_asm_divide`
  * `asm_divide`
* Entender c√≥mo:

  * Se accede a los par√°metros
  * Se usa `idiv`
  * Se retorna un valor

üëâ **No debes modificar este ejercicio.**

---

# Ejercicio 1 ‚Äì Multiply

üìÇ **Carpeta:** `1_Multiply`

### Objetivo

Implementar la multiplicaci√≥n usando ensamblador.

### Qu√© debes completar

Debes completar **dos funciones**:

```c
int c_asm_multiply(int a, int b)
{
    int result;

    __asm {
        // COMPLETAR AQU√ç
    }

    return result;
}
```

```c
__declspec(naked) int asm_multiply(int a, int b)
{
    __asm {
        // COMPLETAR AQU√ç
    }
}
```

### Pasos sugeridos

1. Revisa la funci√≥n `c_multiply`
2. Identifica qu√© registros usar
3. Usa `imul`
4. Aseg√∫rate de devolver el resultado en `EAX`

---

# Ejercicio 2 ‚Äì Pointer Increment

üìÇ **Carpeta:** `2_Pointer`

### Objetivo

Entender **aritm√©tica de punteros** en C y su traducci√≥n a ensamblador.

### Regla clave

```c
p + 1  ‚â†  p + 1 byte
p + 1  =  p + sizeof(tipo)
```

### Qu√© debes completar

```c
short* c_asm_pointer_increment(short *a)
{
    // COMPLETAR
}
```

```c
__declspec(naked) short* asm_pointer_increment(short *a)
{
    __asm {
        // COMPLETAR
    }
}
```

‚ö†Ô∏è **Recuerda:** `short` ocupa **2 bytes**

---

# Ejercicio 3 ‚Äì Absolute Value (Abs)

üìÇ **Carpeta:** `3_Abs`

‚ö†Ô∏è **Este ejercicio es especial**

### Qu√© debes hacer

1. **Completar** la funci√≥n:

```c
int c_asm_absolute(int x)
{
    // COMPLETAR
}
```

2. **Corregir** la funci√≥n:

```c
__declspec(naked) int asm_absolute(int x)
{
    __asm {
        // ESTA FUNCI√ìN TIENE ERRORES
        // DEBES ARREGLARLA
    }
}
```

### Pista

* Debes usar:

  * `cmp`
  * `jge`
  * `neg`

---

# Ejercicio 4 ‚Äì Max

üìÇ **Carpeta:** `4_Max`

### Objetivo

Seleccionar el mayor de dos valores `short`.

### Qu√© debes completar

```c
short c_asm_max(short x, short y)
{
    // COMPLETAR
}
```

```c
__declspec(naked) short asm_max(short x, short y)
{
    __asm {
        // COMPLETAR
    }
}
```

### Pista

* Usa `cmp`
* Usa saltos condicionales (`jge`, `jl`)

---

# Ejercicio 5 ‚Äì Strlen

üìÇ **Carpeta:** `5_Strlen`

### Objetivo

Recorrer una cadena car√°cter por car√°cter hasta encontrar `"\0"`.

### Qu√© debes completar

```c
int c_asm_strlen(char *p)
{
    // COMPLETAR
}
```

```c
__declspec(naked) int asm_strlen(char *p)
{
    __asm {
        // COMPLETAR
    }
}
```

### Pista

* Usa un bucle
* Accede a memoria con `byte ptr`
* Incrementa el puntero

---

# Ejercicio 6 ‚Äì Reduction

üìÇ **Carpeta:** `6_Reduction`

### Objetivo

Trabajar con arreglos y bucles en ensamblador.

### Qu√© debes completar

```c
unsigned char c_asm_vector_multiply(unsigned char *v, int s)
{
    // COMPLETAR
}
```

```c
__declspec(naked) unsigned char asm_vector_multiply(unsigned char *v, int s)
{
    __asm {
        // COMPLETAR
    }
}
```

### Pista

* Usa un √≠ndice
* Recuerda que `unsigned char` ocupa 1 byte
* Usa `imul` o `mul`

---

# Ejercicio 7 ‚Äì Shift (Desplazamiento de bits)

üìÇ **Carpeta:** `7_Shift`

---

## Objetivo

El objetivo de este ejercicio es **aprender a manipular datos a nivel de bits** utilizando ensamblador IA-32, espec√≠ficamente mediante la instrucci√≥n de **desplazamiento a la izquierda (`shl`)** aplicada a los elementos de un vector.

Este ejercicio refuerza los siguientes conceptos:

* Uso de bucles en ensamblador
* Acceso a arreglos mediante punteros
* Operaciones bit a bit
* Diferencia entre operaciones aritm√©ticas y operaciones a nivel de bits

---

## Descripci√≥n del problema

Se recibe un vector de tipo `unsigned char` y su tama√±o. El programa debe recorrer el vector y **desplazar a la izquierda en 1 bit cada uno de sus elementos**.

En C, la operaci√≥n que se realiza es:

```c
vec[i] <<= 1;
```

Esto implica que:

* Todos los bits se mueven una posici√≥n a la izquierda
* El bit m√°s significativo se pierde
* Se introduce un 0 por el bit menos significativo

---

## Qu√© debes completar

Debes completar **dos funciones**, siguiendo exactamente el estilo de los ejercicios anteriores:

### 1. Funci√≥n C + ensamblador en l√≠nea

```c
void c_asm_vector_shift_left(unsigned char *v, int s)
{
    __asm {
        // COMPLETAR AQU√ç
    }
}
```

### 2. Funci√≥n completamente en ensamblador

```c
__declspec(naked) void asm_vector_shift_left(unsigned char *v, int s)
{
    __asm {
        // COMPLETAR AQU√ç
    }
}
```

‚ö†Ô∏è **No debes modificar ninguna otra parte del c√≥digo.**

---

## Pistas importantes

* `unsigned char` ocupa **1 byte**
* Para acceder a un elemento del vector puedes usar:

  ```asm
  byte ptr [base + √≠ndice]
  ```
* Debes usar un **registro como contador del bucle**
* La instrucci√≥n de desplazamiento es:

  ```asm
  shl reg8, 1
  ```

---

## Validaci√≥n

* El programa ya incluye funciones para:

  * Imprimir los vectores
  * Comparar el resultado en C y en ASM
* **Si los vectores no coinciden, el test fallar√°**
* Todos los tests deben mostrar `PASS`

---

## Reglas generales

* No cambies el `main`
* No cambies el comando de compilaci√≥n
* Todas las validaciones ya est√°n implementadas
* Si un test falla, tu ensamblador es incorrecto
* **El ensamblador debe producir exactamente el mismo efecto que el c√≥digo C.**
* No se eval√∫a eficiencia, solo **correcci√≥n y comprensi√≥n del c√≥digo**.

---

## Consejo final

üëâ **Si tu c√≥digo C funciona pero el ASM no, el error est√° en:**

* Registros incorrectos
* Tama√±o de datos incorrecto
* Falta de pr√≥logo/ep√≠logo
* No devolver el resultado en `EAX`
